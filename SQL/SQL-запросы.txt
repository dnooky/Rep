select concat('текст перед значенирем поля 1', название поля 1; 	- объединить 2 поля в одно с добавлением какого-либо текста
'текст перед значением поля 2', название поля 2; итд) 				

select first_name || last_name 			- то же самое. что и первое
																												
select trim('A ' from description) - 		удалить из названия букву А с пробелом

select substring(title, 1, strpos(title, ' ') - 1) - 	удалить из подстроки в поле title, все, что идет после пробела 
														(title - название поля, 1 - с какого символа искать(брать), strpos(title, ' ' - что именно ищем для удаления))
														в конце обязательно "-1" т.к. берем все ДО пробела, а не включая пробел
											
select trim(leading/trailing from ' ' || название поля || ' ') - удалить пробелы в начале/в конце значения поля

WHERE payment_date between '2007-03-01' and '2007-03-31' - условия для выборки в диапазоне (например дат)

WHERE title LIKE/NOT LIKE '%какой-то текст%' - 	условия для выборки, с содержанием/исключением в строке какого-то текста

ctrl + "/" - 					закомментировать выделенные строки

where mod(payment_id, 10) = 1 - условия для выборки числа, у которого последняя цифра 1(остаток от деления на 10 равен 1)

order by first_name desc/asc, last_name desc/asc - отсортировать по нескольким полям по убыванию/возрастанию

select distinct substring(first_name, 1, 3) - вывести уникальные значения первых трех букв из поля first_name
from actor

select distinct on (staff_id)  - 	ТОЛЬКО ДЛЯ POSTGRE выбрать уникальное значение только по 1 полю (иначе будет выбираться уникальная комбинация всех полей)
staff_id,							по умолчанию дистникт выбирает самое маленькое значение. Чтобы выбрать самое большое значение поля нужно добавить
amount								order by указав обязательно поле в скобках (у distinct) и затем все нужные поля
from payment
order by staff_id, amount desc;

inner join actor a             -   если при соединении таблиц в разных таблицах поля называются одинаково, можно сократить написание до "using (название поля)"
using (actor_id) 					при этом поле, по которому происходит соединение в результате будет выведено только 1 раз

select *							- left join добавляет к левой таблице (film) добавляет правую (inventory)			
from film f LEFT JOIN inventory i 	- right join делает наоборот, к правой (inventory) добавляет левую (film)
using (film_id)						- full join просто соединяет обе таблицы

select f.title,											- cross join выполняет декартово произведение. Выводит все возможные комбинации одного поля с другим
a.first_name || ' ' || a.last_name as actor_name
from film f 
CROSS JOIN actor a

select 													- запрос с группировкой по полю rating
	rating,
	count(*) films_count,								- посчитать кол-во в 1 группе
	sum(название поля) as total_length,					- просуммировать все значения из группы
	max(название поля) as max_length,					- макс.значение из группы
	min(название поля) as min_length,					- мин. значений из группы
	avg(название поля) as avg_length,
	string_agg(название поля, '; ')						- вывести все значения поля из одной группы через разделитель ";"
from 
	film f
group by
	название поля; 										- по какому полю группировать
	
select 													- запрос с выводом сортировки по кол-ву сгруппированного значения через having
	a.first_name || ' ' || a.last_name as actor_name,
	count(*) as film_number
from 
	actor a
join film_actor fa on
	a.actor_id = fa.actor_id
group by 
	actor_name
having 
	count(*) > 20;

select f.title, f.rating, 															- вывод значения через case (аналог if-else)
case 
	when f.rating = 'G' then 'Нет возрастных ограничений'
	when f.rating = 'PG' then 'Рекомендуется присутствие родителей'
	when f.rating = 'PG-13' then 'Детям до 13 лет просмотр не желателен'
	when f.rating = 'R' then 'Лицам до 17 лет обязательно присутствие взрослого'
	when f.rating = 'NC-17' then 'Нет возрастных ограничений'
	else "Другое ограничение"
end as "Возрастное ограничение"
from film f

limit 50													- Вывести первые 50 строк
offset 50													- Пропустить первые 50 строк

union intersect except